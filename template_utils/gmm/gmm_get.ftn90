!!===================== gmm_get (interface) =====================
!
#ifdef INTERFACEONLY
      interface gmm_get
      integer function gmm_getmeta2(iname,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      type(gmm_metadata), intent(out) :: m               ! attributes (name in attributes is not used)
      end function gmm_getmeta2
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
      integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
#include "gmm_definitions.inc"
      character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
      DATATYPE*DATALENGTH, pointer :: p(DIMS(:,:,:,:))
      type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
      end function Cat(gmm_get,EXTENSION,)
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
      end interface
#endif

#ifndef INTERFACEONLY
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3,#4
#define CODE #1;#2;#3;#4
#define DIM 4
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2,#3
#define CODE #1;#2;#3
#define DIM 3
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1,#2
#define CODE #1;#2
#define DIM 2
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE integer
#define DATACODE 1
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE real
#define DATACODE 2
#define DATALENGTH 4
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#define Cat #1#2#3#4#5#6
#define DIMS #1
#define CODE #1
#define DIM 1
#define DATATYPE complex
#define DATACODE 3
#define DATALENGTH 8
#define EXTENSION Cat(DATACODE,DATALENGTH,DIM)
  integer function Cat(gmm_get,EXTENSION,)(iname,p,m)
  use gmm_internals
  use Cat(pointer_table_data_,EXTENSION,)
  implicit none
   integer :: i, array_rank
  character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
  DATATYPE*DATALENGTH, pointer  :: p(DIMS(:,:,:,:))
  type(gmm_metadata), optional, intent(out) :: m               ! attributes (name in attributes is not used)
!  integer,intent(inout) :: reqid
  include 'gmm_directory_interface.inc'
  type(gmm_metadata) :: m2
  integer*8 :: key
      integer *8 get_address_from
      external get_address_from 

  key = 0
  call check_directory_entry(iname,key)
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then  ! quick check using key was not successful
    call find_directory_entry(iname,key)
  endif
  if(cur_page .eq. 0 .or. cur_entry .eq. 0) then   ! return null entry
    if (present(m)) then
      m%a = GMM_NULL_ATTRIB ! null attributes
      m%l = GMM_NULL_LAYOUT ! null layout
    endif
    nullify(p)
    key= GMM_KEY_NOT_FOUND
    Cat(gmm_get,EXTENSION,) = GMM_VAR_NOT_FOUND
  else
    m2%l=directory(cur_page)%entry(cur_entry)%l
    m2%a=directory(cur_page)%entry(cur_entry)%a
    if (present(m)) m=m2                           ! return a copy of the proper entry
    p=>Cat(gmm_ptrs, EXTENSION,)(directory(cur_page)%entry(cur_entry)%pointer_table_index)%p
    do i=1,4
!      print *,'DEBUG gmm_get m%l(',i,')%n=',m2%l(i)%n
      if (m2%l(i)%n /= 0) array_rank=i
    enddo
!    write(6,'(a,a,a,i2,a,i2)') 'DEBUG gmm_get iname=',iname,' DIM=',DIM,' array_rank=',array_rank
    if (array_rank /= DIM) then
       nullify(p)
       if (present(m)) m = GMM_NULL_METADATA
       Cat(gmm_get,EXTENSION,) = GMM_INCONSISTENT_DIMS
!       print *,'DEBUG gmm_get *** GMM_INCONSISTENT_DIMS ***'
    else
       Cat(gmm_get,EXTENSION,) = GMM_OK
    endif
!    write(6,'(a,a8,a,i4,a,i4,a,i4,a,i10)') 'Debug+++ gmm_get name=',iname,' cur_page=',cur_page,' cur_entry=',cur_entry,' index=',directory(cur_page)%entry(cur_entry)%pointer_table_index,' addr=',get_address_from(p) 
   endif
  end function Cat(gmm_get,EXTENSION,)
!
#undef EXTENSION
#undef  Cat
#undef  DIMS
#undef  CODE
#undef  DIM
#undef  DATATYPE
#undef  DATACODE
#undef  DATALENGTH
#endif
#ifndef INTERFACEONLY
  integer function gmm_getmeta2(iname,m)
#include "gmm_definitions.inc"
    character(len=*), intent(in) :: iname               ! name (partially redundant with attributes)
    type(gmm_metadata), intent(out) :: m               ! attributes (name in attributes is not used)
   integer gmm_getmeta
   external gmm_getmeta
   gmm_getmeta2 = gmm_getmeta(iname, m)
  end function gmm_getmeta2
#endif
